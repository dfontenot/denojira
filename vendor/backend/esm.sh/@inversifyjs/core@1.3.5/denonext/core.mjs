/* esm.sh - @inversifyjs/core@1.3.5 */
import{getReflectMetadata as m,updateReflectMetadata as N}from"/@inversifyjs/reflect-metadata-utils@0.2.4/denonext/reflect-metadata-utils.mjs";import{LazyServiceIdentifier as S}from"/@inversifyjs/common@1.4.0/denonext/common.mjs";var f="named",j="name",I="unmanaged",k="optional",M="inject",w="multi_inject",D="post_construct",C="pre_destroy",G=[M,w,j,I,f,k],h=Symbol.for("@inversifyjs/core/InversifyCoreError"),u=class t extends Error{[h];kind;constructor(e,n,r){super(n,r),this[h]=!0,this.kind=e}static is(e){return typeof e=="object"&&e!==null&&e[h]===!0}static isErrorOfKind(e,n){return t.is(e)&&e.kind===n}},d,s;function b(t,e){let n=[];for(let r=0;r<e.length;++r)e[r]===void 0&&n.push(r);if(n.length>0)throw new u(d.missingInjectionDecorator,`Found unexpected missing metadata on type "${t.name}" at constructor indexes "${n.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`)}function O(t){return{kind:s.singleInjection,name:void 0,optional:!1,tags:new Map,targetName:void 0,value:t}}function A(t){let e=t.find(o=>o.key===M),n=t.find(o=>o.key===w);if(t.find(o=>o.key===I)!==void 0)return function(o,c){if(c!==void 0||o!==void 0)throw new u(d.missingInjectionDecorator,"Expected a single @inject, @multiInject or @unmanaged metadata");return{kind:s.unmanaged}}(e,n);if(n===void 0&&e===void 0)throw new u(d.missingInjectionDecorator,"Expected @inject, @multiInject or @unmanaged metadata");let r=t.find(o=>o.key===f),i=t.find(o=>o.key===k),a=t.find(o=>o.key===j);return{kind:e===void 0?s.multipleInjection:s.singleInjection,name:r?.value,optional:i!==void 0,tags:new Map(t.filter(o=>G.every(c=>o.key!==c)).map(o=>[o.key,o.value])),targetName:a?.value,value:e===void 0?n?.value:e.value}}function x(t,e,n){try{return A(n)}catch(r){throw u.isErrorOfKind(r,d.missingInjectionDecorator)?new u(d.missingInjectionDecorator,`Expected a single @inject, @multiInject or @unmanaged decorator at type "${t.name}" at constructor arguments at index "${e.toString()}"`,{cause:r}):r}}function K(t){let e=m(t,"design:paramtypes"),n=m(t,"inversify:tagged"),r=[];if(n!==void 0)for(let[i,a]of Object.entries(n)){let o=parseInt(i);r[o]=x(t,o,a)}if(e!==void 0){for(let i=0;i<e.length;++i)if(r[i]===void 0){let a=e[i];r[i]=O(a)}}return b(t,r),r}function T(t,e,n){try{return A(n)}catch(r){throw u.isErrorOfKind(r,d.missingInjectionDecorator)?new u(d.missingInjectionDecorator,`Expected a single @inject, @multiInject or @unmanaged decorator at type "${t.name}" at property "${e.toString()}"`,{cause:r}):r}}function _(t){let e=m(t,"inversify:tagged_props"),n=new Map;if(e!==void 0)for(let r of Reflect.ownKeys(e)){let i=e[r];n.set(r,T(t,r,i))}return n}function $(t){let e=m(t,D),n=m(t,C);return{constructorArguments:K(t),lifecycle:{postConstructMethodName:e?.value,preDestroyMethodName:n?.value},properties:_(t)}}function F(t,e){let n=e.getConstructorMetadata(t),r=[];for(let[i,a]of Object.entries(n.userGeneratedMetadata)){let o=parseInt(i);r[o]=x(t,o,a)}if(n.compilerGeneratedMetadata!==void 0){for(let i=0;i<n.compilerGeneratedMetadata.length;++i)if(r[i]===void 0){let a=n.compilerGeneratedMetadata[i];r[i]=O(a)}}return b(t,r),r}function R(t,e){let n=e.getPropertiesMetadata(t),r=new Map;for(let i of Reflect.ownKeys(n)){let a=n[i];r.set(i,T(t,i,a))}return r}function W(t,e){let n=m(t,D),r=m(t,C);return{constructorArguments:F(t,e),lifecycle:{postConstructMethodName:n?.value,preDestroyMethodName:r?.value},properties:R(t,e)}}function E(t){return Object.getPrototypeOf(t.prototype)?.constructor}function L(t){return t.kind===s.unmanaged?[{key:I,value:!0}]:function(e){let n=[P(e)];e.name!==void 0&&n.push({key:f,value:e.name}),e.optional&&n.push({key:k,value:!0});for(let[r,i]of e.tags)n.push({key:r,value:i});return e.targetName!==void 0&&n.push({key:j,value:e.targetName}),n}(t)}function P(t){let e;switch(t.kind){case s.multipleInjection:e={key:w,value:t.value};break;case s.singleInjection:e={key:M,value:t.value}}return e}(function(t){t[t.injectionDecoratorConflict=0]="injectionDecoratorConflict",t[t.missingInjectionDecorator=1]="missingInjectionDecorator",t[t.planning=2]="planning",t[t.unknown=3]="unknown"})(d||(d={})),function(t){t[t.multipleInjection=0]="multipleInjection",t[t.singleInjection=1]="singleInjection",t[t.unmanaged=2]="unmanaged"}(s||(s={}));var y=class{#e;constructor(e){this.#e=e}startsWith(e){return this.#e.startsWith(e)}endsWith(e){return this.#e.endsWith(e)}contains(e){return this.#e.includes(e)}equals(e){return this.#e===e}value(){return this.#e}},v="@inversifyjs/core/targetId",g=class{#e;#n;#r;#t;#i;#o;constructor(e,n,r){this.#n=function(){let i=m(Object,v)??0;return i===Number.MAX_SAFE_INTEGER?N(Object,v,i,()=>Number.MIN_SAFE_INTEGER):N(Object,v,i,a=>a+1),i}(),this.#r=e,this.#t=void 0,this.#e=n,this.#i=new y(typeof e=="string"?e:e.toString().slice(7,-1)),this.#o=r}get id(){return this.#n}get identifier(){return this.#r}get metadata(){return this.#t===void 0&&(this.#t=L(this.#e)),this.#t}get name(){return this.#i}get type(){return this.#o}get serviceIdentifier(){return S.is(this.#e.value)?this.#e.value.unwrap():this.#e.value}getCustomTags(){return[...this.#e.tags.entries()].map(([e,n])=>({key:e,value:n}))}getNamedTag(){return this.#e.name===void 0?null:{key:f,value:this.#e.name}}hasTag(e){return this.metadata.some(n=>n.key===e)}isArray(){return this.#e.kind===s.multipleInjection}isNamed(){return this.#e.name!==void 0}isOptional(){return this.#e.optional}isTagged(){return this.#e.tags.size>0}matchesArray(e){return this.isArray()&&this.#e.value===e}matchesNamedTag(e){return this.#e.name===e}matchesTag(e){return n=>this.metadata.some(r=>r.key===e&&r.value===n)}},X=t=>function(e,n){return function(r){let i=e(r),a=E(r);for(;a!==void 0&&a!==Object;){let c=n(a);for(let[l,p]of c)i.properties.has(l)||i.properties.set(l,p);a=E(a)}let o=[];for(let c of i.constructorArguments)if(c.kind!==s.unmanaged){let l=c.targetName??"";o.push(new g(l,c,"ConstructorArgument"))}for(let[c,l]of i.properties)if(l.kind!==s.unmanaged){let p=l.targetName??c;o.push(new g(p,l,"ClassProperty"))}return o}}(t===void 0?$:e=>W(e,t),t===void 0?_:e=>R(e,t));export{s as ClassElementMetadataKind,g as LegacyTargetImpl,A as getClassElementMetadataFromLegacyMetadata,$ as getClassMetadata,W as getClassMetadataFromMetadataReader,X as getTargets};
//# sourceMappingURL=core.mjs.map